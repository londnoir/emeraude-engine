/*
 * src/Scenes/Scene.hpp
 * This file is part of Emeraude-Engine
 *
 * Copyright (C) 2010-2025 - Sébastien Léon Claude Christian Bémelmans "LondNoir" <londnoir@gmail.com>
 *
 * Emeraude-Engine is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * Emeraude-Engine is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Emeraude-Engine; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Complete project and additional information can be found at :
 * https://github.com/londnoir/emeraude-engine
 *
 * --- THIS IS AUTOMATICALLY GENERATED, DO NOT CHANGE ---
 */

#pragma once

/* STL inclusions. */
#include <cstddef>
#include <cstdint>
#include <array>
#include <map>
#include <vector>
#include <set>
#include <string>
#include <any>
#include <memory>
#include <mutex>

/* Local inclusions for inheritances. */
#include "Libs/NameableTrait.hpp"
#include "Libs/ObservableTrait.hpp"
#include "Libs/ObserverTrait.hpp"
#include "Libs/Time/EventTrait.hpp"

/* Local inclusions for usages. */
#include "Libs/Randomizer.hpp"
#include "Graphics/Renderable/AbstractBackground.hpp"
#include "Graphics/Renderable/SceneAreaInterface.hpp"
#include "Graphics/Renderable/SeaLevelInterface.hpp"
#include "Saphir/EffectInterface.hpp"
#include "LightSet.hpp"
#include "OctreeSector.hpp"
#include "StaticEntity.hpp"
#include "Node.hpp"
#include "NodeController.hpp"
#include "RenderBatch.hpp"

/* Forward Declarations */
namespace EmEn::Graphics
{
	class Renderer;
}

namespace EmEn::Scenes
{
	/**
	 * @brief Structure to configure the scene octree initialization.
	 */
	struct SceneOctreeOptions
	{
		size_t renderingOctreeAutoExpandAt{256};
		size_t renderingOctreeReserve{0};
		size_t physicsOctreeAutoExpandAt{32};
		size_t physicsOctreeReserve{3};
	};

	/**
	 * @brief Class that describe a whole scene through a nodes structure.
	 * @extends EmEn::Libs::NameableTrait A scene is a named object in the engine.
	 * @extends EmEn::Libs::Time::EventTrait A scene can have timed events.
	 * @extends EmEn::Libs::ObserverTrait The scene will observe the scene node tree and static entity list.
	 * @extends EmEn::Libs::ObservableTrait Scene will notify its content change.
	 */
	class Scene final : public Libs::NameableTrait, public Libs::Time::EventTrait< uint32_t, std::milli >, public Libs::ObserverTrait, public Libs::ObservableTrait
	{
		public:

			/** @brief Observable notification codes. */
			enum NotificationCode
			{
				/* Enumeration boundary. */
				MaxEnum
			};

			/** @brief Class identifier. */
			static constexpr auto ClassId{"Scene"};

			/** @brief Observable class unique identifier. */
			static const size_t ClassUID;

			/**
			 * @brief Constructs a scene.
			 * @param graphicsRenderer A reference to the graphics renderer.
			 * @param audioManager A reference to the audio manager.
			 * @param name A reference to a string to name it.
			 * @param boundary The distance in all directions to limit the area.
			 * @param background A reference to a background smart pointer. Default autogenerated.
			 * @param sceneArea A reference to a sceneArea smart pointer. Default autogenerated.
			 * @param seaLevel A reference to a seaLevel smart pointer. Default none.
			 * @param octreeOptions A reference to an option struct. Defaults.
			 */
			Scene (Graphics::Renderer & graphicsRenderer, Audio::Manager & audioManager, const std::string & name, float boundary, const std::shared_ptr< Graphics::Renderable::AbstractBackground > & background = nullptr, const std::shared_ptr< Graphics::Renderable::SceneAreaInterface > & sceneArea = nullptr, const std::shared_ptr< Graphics::Renderable::SeaLevelInterface > & seaLevel = nullptr, const SceneOctreeOptions & octreeOptions = {}) noexcept;

			/**
			 * @brief Copy constructor.
			 * @param copy A reference to the copied instance.
			 */
			Scene (const Scene & copy) noexcept = delete;

			/**
			 * @brief Move constructor.
			 * @param copy A reference to the copied instance.
			 */
			Scene (Scene && copy) noexcept = delete;

			/**
			 * @brief Copy assignment.
			 * @param copy A reference to the copied instance.
			 * @return Scene &
			 */
			Scene & operator= (const Scene & copy) noexcept = delete;

			/**
			 * @brief Move assignment.
			 * @param copy A reference to the copied instance.
			 * @return Scene &
			 */
			Scene & operator= (Scene && copy) noexcept = delete;

			/**
			 * @brief Destructs the scene.
			 */
			~Scene () override;

			/** @copydoc EmEn::Libs::ObservableTrait::classUID() const */
			[[nodiscard]]
			size_t
			classUID () const noexcept override
			{
				return ClassUID;
			}

			/** @copydoc EmEn::Libs::ObservableTrait::is() const */
			[[nodiscard]]
			bool
			is (size_t classUID) const noexcept override
			{
				return classUID == ClassUID;
			}

			/**
			 * @brief Initializes the scene and get it ready for playing.
			 * @param settings A reference to core settings.
			 * @return bool
			 */
			[[nodiscard]]
			bool initialize (Settings & settings) noexcept;

			/**
			 * @brief Prepares the scene to be removed from playing.
			 * @return void
			 */
			void shutdown () noexcept;

			/**
			 * @brief Sets the scene boundary.
			 * @param boundary A value from the center of the scene to limit of the scene.
			 * @return void
			 */
			void setBoundary (float boundary) noexcept
			{
				m_boundary = std::abs(boundary);

				this->rebuildRenderingOctree(true);

				this->rebuildPhysicsOctree(true);
			}

			/**
			 * @brief Returns the boundary in one direction.
			 * @note To get the total size of an axis, you need to multiply it by two or use SceneAreaInterface::size().
			 * @return float
			 */
			[[nodiscard]]
			float
			boundary () const noexcept
			{
				return m_boundary;
			}

			/**
			 * @brief Returns the square size of the area.
			 * @return float
			 */
			[[nodiscard]]
			float
			size () const noexcept
			{
				return m_boundary * 2;
			}

			/**
			 * @brief Returns the float randomizer from the scene.
			 * @return Libs::Randomizer< float > &
			 */
			[[nodiscard]]
			Libs::Randomizer< float > &
			randomizer () noexcept
			{
				return m_randomizer;
			}

			/**
			 * @brief Returns the execution time of the scene in microseconds.
			 * @return uint64_t
			 */
			[[nodiscard]]
			uint64_t
			lifetimeUS () const noexcept
			{
				return m_lifetimeUS;
			}

			/**
			 * @brief Returns the execution time of the scene in milliseconds.
			 * @return uint32_t
			 */
			[[nodiscard]]
			uint32_t
			lifetimeMS () const noexcept
			{
				return m_lifetimeMS;
			}

			/**
			 * @brief Returns the number of cycles executed by the scene.
			 * @return size_t
			 */
			[[nodiscard]]
			size_t
			cycle () const noexcept
			{
				return m_cycle;
			}

			/**
			 * @brief Sets the scene physical environment properties.
			 * @param properties A reference to a physical environment properties.
			 * @return void
			 */
			void
			setPhysicalEnvironmentProperties (const Physics::PhysicalEnvironmentProperties & properties) noexcept
			{
				m_physicalEnvironmentProperties = properties;
			}

			/**
			 * @brief Creates a static entity in the scene.
			 * @param name The name of the entity.
			 * @param coordinates A reference to a coordinates for the initial location of the entity. Default origin.
			 * @return std::shared_ptr< StaticEntity >
			 */
			[[nodiscard]]
			std::shared_ptr< StaticEntity > createStaticEntity (const std::string & name, const Libs::Math::CartesianFrame< float > & coordinates = {}) noexcept;

			/**
			 * @brief Creates a static entity in the scene using only a position.
			 * @param name The name of the entity.
			 * @param position A reference to a vector.
			 * @return std::shared_ptr< StaticEntity >
			 */
			[[nodiscard]]
			std::shared_ptr< StaticEntity >
			createStaticEntity (const std::string & name, const Libs::Math::Vector< 3, float > & position) noexcept
			{
				return this->createStaticEntity(name, Libs::Math::CartesianFrame< float >{position});
			}

			/**
			 * @brief Removes a static entity from the scene.
			 * @param name A reference to a string for the entity name.
			 * @return bool
			 */
			bool removeStaticEntity (const std::string & name) noexcept;

			/**
			 * @brief Adds a global effect to the scene.
			 * @param effect A reference to an effect interface smart pointer.
			 * @return void
			 */
			void
			addEnvironmentEffect (const std::shared_ptr< Saphir::EffectInterface > & effect) noexcept
			{
				/* We don't want to notify an effect twice. */
				// FIXME: Use a std::set so !
				if ( m_environmentEffects.contains(effect) )
				{
					return;
				}

				m_environmentEffects.emplace(effect);
			}

			/**
			 * @brief Returns whether a global effect is already present on the scene.
			 * @param effect A reference to an effect interface smart pointer.
			 * @return bool
			 */
			[[nodiscard]]
			bool
			isEnvironmentEffectPresent (const std::shared_ptr< Saphir::EffectInterface > & effect) const noexcept
			{
				return m_environmentEffects.contains(effect);
			}

			/**
			 * @brief Clears every effect from the scene.
			 * @return void
			 */
			void
			clearEnvironmentEffects () noexcept
			{
				m_environmentEffects.clear();
			}

			/**
			 * @brief Destroys the whole scene.
			 * @return void
			 */
			void destroy () noexcept;

			/**
			 * @brief Rebuilds the scene rendering octree.
			 * @param keepElements Keep elements from the previous octrees. Default true.
			 * @return void
			 */
			bool rebuildRenderingOctree (bool keepElements = true) noexcept;

			/**
			 * @brief Rebuilds the physics rendering octree.
			 * @param keepElements Keep elements from the previous octrees. Default true.
			 * @return void
			 */
			bool rebuildPhysicsOctree (bool keepElements = true) noexcept;

			/**
			 * @brief Removes all nodes.
			 * @return void
			 */
			void resetNodeTree () const noexcept;

			/**
			 * @brief This method is called by the Core every logic cycle.
			 * @param engineCycle The cycle number of the engine.
			 * @return void
			 */
			void processLogics (size_t engineCycle) noexcept;

			/**
			 * @brief Updates the video memory just before rendering.
			 * @note This should only update things which must be ready for rendering.
			 * @return void
			 */
			void updateVideoMemory () const noexcept;

			/**
			 * @brief Performs a shadow casting pass of the scene.
			 * @param renderTarget A reference to the render target smart pointer.
			 * @param commandBuffer A reference to a command buffer.
			 * @return void
			 */
			void castShadows (const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget, const Vulkan::CommandBuffer & commandBuffer) noexcept;

			/**
			 * @brief Renders the scene to a render target.
			 * @param renderTarget A reference to the render target smart pointer.
			 * @param commandBuffer A reference to a command buffer.
			 * @return void
			 */
			void render (const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget, const Vulkan::CommandBuffer & commandBuffer) noexcept;

			/**
			 * @brief Returns the master control manager.
			 * @return const AVConsole::Manager &
			 */
			[[nodiscard]]
			const AVConsole::Manager &
			AVConsoleManager () const noexcept
			{
				return m_AVConsoleManager;
			}

			/**
			 * @brief Returns the master control manager.
			 * @return AVConsole::Manager &
			 */
			[[nodiscard]]
			AVConsole::Manager &
			AVConsoleManager () noexcept
			{
				return m_AVConsoleManager;
			}

			/**
			 * @brief Returns the light set of the scene.
			 * @return const LightSet &
			 */
			[[nodiscard]]
			const LightSet &
			lightSet () const noexcept
			{
				return m_lightSet;
			}

			/**
			 * @brief Returns the light set of the scene.
			 * @return LightSet &
			 */
			[[nodiscard]]
			LightSet &
			lightSet () noexcept
			{
				return m_lightSet;
			}

			/**
			 * @brief Returns the node controller.
			 * @return const NodeController &
			 */
			[[nodiscard]]
			const NodeController &
			nodeController () const noexcept
			{
				return m_nodeController;
			}

			/**
			 * @brief Returns the node controller.
			 * @return NodeController &
			 */
			[[nodiscard]]
			NodeController & nodeController () noexcept
			{
				return m_nodeController;
			}

			/**
			 * @brief Returns the scene physical environment properties.
			 * @return const Physics::PhysicalEnvironmentProperties &
			 */
			[[nodiscard]]
			const Physics::PhysicalEnvironmentProperties &
			physicalEnvironmentProperties () const noexcept
			{
				return m_physicalEnvironmentProperties;
			}

			/**
			 * @brief Returns the scene physical environment properties.
			 * @return Physics::PhysicalEnvironmentProperties &
			 */
			[[nodiscard]]
			Physics::PhysicalEnvironmentProperties &
			physicalEnvironmentProperties () noexcept
			{
				return m_physicalEnvironmentProperties;
			}

			/**
			 * @brief Sets the scene background.
			 * @param background A reference to a background smart pointer.
			 * @return void
			 */
			void
			setBackground (const std::shared_ptr< Graphics::Renderable::AbstractBackground > & background) noexcept
			{
				m_background = background;

				this->registerSceneVisualComponents();
			}

			/**
			 * @brief Returns the current background of the scene.
			 * @return std::shared_ptr< Graphics::Renderable::AbstractBackground >
			 */
			[[nodiscard]]
			std::shared_ptr< Graphics::Renderable::AbstractBackground >
			background () const noexcept
			{
				return m_background;
			}

			/**
			 * @brief Sets the scene sceneArea.
			 * @param sceneArea A reference to a sceneArea smart pointer.
			 * @return void
			 */
			void
			setSceneArea (const std::shared_ptr< Graphics::Renderable::SceneAreaInterface > & sceneArea) noexcept
			{
				m_sceneArea = sceneArea;

				this->registerSceneVisualComponents();
			}

			/**
			 * @brief Returns the current scene area.
			 * @return std::shared_ptr< Graphics::Renderable::SceneAreaInterface >
			 */
			[[nodiscard]]
			std::shared_ptr< Graphics::Renderable::SceneAreaInterface >
			sceneArea () const noexcept
			{
				return m_sceneArea;
			}

			/**
			 * @brief Sets the scene sea level.
			 * @param seaLevel A reference to a background smart pointer.
			 * @return void
			 */
			void
			setSeaLevel (const std::shared_ptr< Graphics::Renderable::SeaLevelInterface > & seaLevel) noexcept
			{
				m_seaLevel = seaLevel;

				this->registerSceneVisualComponents();
			}

			/**
			 * @brief Returns the current water level.
			 * @return std::shared_ptr< Graphics::Renderable::SeaLevelInterface >
			 */
			[[nodiscard]]
			std::shared_ptr< Graphics::Renderable::SeaLevelInterface >
			seaLevel () const noexcept
			{
				return m_seaLevel;
			}

			/**
			 * @brief Returns the root scene node from the scene.
			 * @return std::shared_ptr< Node >
			 */
			[[nodiscard]]
			std::shared_ptr< Node >
			root () const noexcept
			{
				return m_rootNode;
			}

			/**
			 * @brief Searches from the top oh the node tree the first named node.
			 * @param nodeName A reference to a string.
			 * @return std::shared_ptr< Node >
			 */
			[[nodiscard]]
			std::shared_ptr< Node > findNode (const std::string & nodeName) const noexcept;

			/**
			 * @brief Returns the static entity list.
			 * @return const std::map< std::string , std::shared_ptr< StaticEntity > > &
			 */
			[[nodiscard]]
			const std::map< std::string , std::shared_ptr< StaticEntity > > &
			staticEntities () const noexcept
			{
				return m_staticEntities;
			}

			/**
			 * @brief Tries to find a static entity by its name.
			 * @note Check for a nullptr return !
			 * @param staticEntityName A reference to a string.
			 * @return std::shared_ptr< StaticEntity >
			 */
			[[nodiscard]]
			std::shared_ptr< StaticEntity >
			findStaticEntity (const std::string & staticEntityName) const noexcept
			{
				auto staticEntityIt = m_staticEntities.find(staticEntityName);

				if ( staticEntityIt == m_staticEntities.end() )
				{
					return nullptr;
				}

				return staticEntityIt->second;
			}

			/**
			 * @brief Returns a list of modifiers present in the scene.
			 * @return const std::set< std::shared_ptr< Component::AbstractModifier > > &
			 */
			[[nodiscard]]
			const std::set< std::shared_ptr< Component::AbstractModifier > > &
			modifiers () const noexcept
			{
				return m_modifiers;
			}

			/**
			 * @brief Returns the list of active global effects in the scene.
			 * @return const Saphir::EffectsList &
			 */
			[[nodiscard]]
			const Saphir::EffectsList &
			environmentEffects () const noexcept
			{
				return m_environmentEffects;
			}

			/**
			 * @brief Checks if a position is inside the scene area.
			 * @param worldPosition An absolute position.
			 * @return bool
			 */
			[[nodiscard]]
			bool contains (const Libs::Math::Vector< 3, float > & worldPosition) const noexcept;

			/**
			 * @brief Returns a random position within the scene area.
			 * @return Libs::Math::Vector< 3, float >
			 */
			Libs::Math::Vector< 3, float >
			getRandomPosition () const noexcept
			{
				return {
					Libs::Utility::quickRandom(-m_boundary, m_boundary),
					Libs::Utility::quickRandom(-m_boundary, m_boundary),
					Libs::Utility::quickRandom(-m_boundary, m_boundary)
				};
			}

			/**
			 * @brief Returns node count and depth.
			 * @return std::array< size_t, 2 >
			 */
			[[nodiscard]]
			std::array< size_t, 2 > getNodeStatistics () const noexcept;

			/**
			 * @brief Shows a compass.
			 * @note This a debug utility.
			 * @return bool
			 */
			bool enableCompassDisplay () noexcept;

			/**
			 * @brief Removes the scene compass.
			 * @note This a debug utility.
			 * @return void
			 */
			void disableCompassDisplay () noexcept;

			/**
			 * @brief Returns whether the scene compass is displayed.
			 * @note This a debug utility.
			 * @return bool
			 */
			[[nodiscard]]
			bool compassDisplayEnabled () const noexcept;

			/**
			 * @brief Toggles the display of the scene compass.
			 * @note This a debug utility.
			 * @return bool
			 */
			bool toggleCompassDisplay () noexcept;

			/**
			 * @brief Shows the ground zero of the scene.
			 * @note This a debug utility.
			 * @return bool
			 */
			bool enableGroundZeroDisplay () noexcept;

			/**
			 * @brief Removes the ground zero of the scene.
			 * @note This a debug utility.
			 * @return void
			 */
			void disableGroundZeroDisplay () noexcept;

			/**
			 * @brief Returns whether the ground zero is displayed.
			 * @note This a debug utility.
			 * @return bool
			 */
			[[nodiscard]]
			bool groundZeroDisplayEnabled () const noexcept;

			/**
			 * @brief Toggles the display of ground zero.
			 * @note This a debug utility.
			 * @return void
			 */
			void toggleGroundZeroDisplay () noexcept;

			/**
			 * @brief Shows the scene boundary planes.
			 * @note This a debug utility.
			 * @return bool
			 */
			bool enableBoundaryPlanesDisplay () noexcept;

			/**
			 * @brief Removes the scene boundary planes.
			 * @note This a debug utility.
			 * @return void
			 */
			void disableBoundaryPlanesDisplay () noexcept;

			/**
			 * @brief Returns whether the scene boundary planes are displayed.
			 * @note This a debug utility.
			 * @return bool
			 */
			[[nodiscard]]
			bool boundaryPlanesDisplayEnabled () const noexcept;

			/**
			 * @brief Toggles the display of scene boundary planes.
			 * @note This a debug utility.
			 * @return void
			 */
			void toggleBoundaryPlanesDisplay () noexcept;

			/**
			 * @brief Refreshes all renderable instances used in the scene.
			 * @param renderTarget A reference to a render target smart pointer.
			 * @return void
			 */
			void refreshRenderableInstances (const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget) const noexcept;

			/**
			 * @brief Applies scene modifiers on a node.
			 * @param node A reference to a node.
			 * @return void
			 */
			void applyModifiers (Node & node) const noexcept;

			/**
			 * @brief Returns a string with the node system statistics.
			 * @note Debug purpose.
			 * @param showTree Enable the scene node tree. Default false.
			 * @return std::string
			 */
			[[nodiscard]]
			std::string getNodeSystemStatistics (bool showTree = false) const noexcept;

			/**
			 * @brief Returns a string with the static entity system statistics.
			 * @note Debug purpose.
			 * @param showTree Enable the static entity tree. Default false.
			 * @return std::string
			 */
			[[nodiscard]]
			std::string getStaticEntitySystemStatistics (bool showTree = false) const noexcept;

			/**
			 * @brief Returns a string with the sector system statistics.
			 * @note Debug purpose.
			 * @param showTree Enable the sector tree. Default false.
			 * @return std::string
			 */
			[[nodiscard]]
			std::string getSectorSystemStatistics (bool showTree = false) const noexcept;

		private:

			/** @copydoc EmEn::Libs::ObserverTrait::onNotification() */
			[[nodiscard]]
			bool onNotification (const ObservableTrait * observable, int notificationCode, const std::any & data) noexcept override;

			/**
			 * @brief Updates the render lists from a point of view.
			 * @param renderTarget A reference to the render target smart pointer.
			 * @param isShadowCasting Enable the shadow map render list.
			 * @return bool
			 */
			bool populateRenderLists (const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget, bool isShadowCasting) noexcept;

			/**
			 * @brief Inserts a renderable instance in render lists for shadows casting.
			 * @param renderTarget A reference to the render target smart pointer.
			 * @param renderableInstance A reference to a renderable instance.
			 * @param distance The distance from the camera.
			 * @return void
			 */
			void insertInShadowCastLists (const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget, const std::shared_ptr< Graphics::RenderableInstance::Abstract > & renderableInstance, float distance) noexcept;

			/**
			 * @brief Inserts a renderable instance in render lists.
			 * @param renderTarget A reference to the render target smart pointer.
			 * @param renderableInstance A reference to a renderable instance.
			 * @param distance The distance from the camera.
			 * @return void
			 */
			void insertInRenderLists (const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget, const std::shared_ptr< Graphics::RenderableInstance::Abstract > & renderableInstance, float distance) noexcept;

			/**
			 * @brief Renders a specific selection of objects;
			 * @param renderTarget A reference to the render target smart pointer.
			 * @param commandBuffer A reference to the command buffer.
			 * @param unlightedObjects A reference to an unlighted renderable list.
			 * @param lightedObjects A reference to a lighted renderable list.
			 * @return void
			 */
			void renderSelection (const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget, const Vulkan::CommandBuffer & commandBuffer, const RenderBatch::List & unlightedObjects, const RenderBatch::List & lightedObjects) const noexcept;

			/**
			 * @brief Loops over each renderable instance of the scene
			 * @param function A reference to a function.
			 * @return void
			 */
			void forEachRenderableInstance (const std::function< bool (const std::shared_ptr< Graphics::RenderableInstance::Abstract > & renderableInstance) > & function) const noexcept;

			/**
			 * @brief Checks a notification from the master console control.
			 * @param notificationCode The notification code from AVConsole::Console::NotificationCode enum.
			 * @param data A reference to the notification payload.
			 * @return void
			 */
			void checkAVConsoleNotification (int notificationCode, const std::any & data) const noexcept;

			/**
			 * @brief Checks a notification from a scene node.
			 * @param notificationCode The notification code from Node::NotificationCode enum.
			 * @param data A reference to the notification payload.
			 * @return bool
			 */
			[[nodiscard]]
			bool checkRootNodeNotification (int notificationCode, const std::any & data) noexcept;

			/**
			 * @brief Checks a notification from a scene entity.
			 * @param notificationCode The notification code from AbstractEntity::NotificationCode enum.
			 * @param data A reference to the notification payload.
			 * @return bool
			 */
			bool checkEntityNotification (int notificationCode, const std::any & data) noexcept;

			/**
			 * @brief Initializes the base component (camera, microphone) of the scene.
			 * @note This is a sub-part of initialize() method.
			 * @return bool
			 */
			[[nodiscard]]
			bool initializeBaseComponents () const noexcept;

			/**
			 * @brief Saves scene global visual components.
			 * @return void
			 */
			void registerSceneVisualComponents () noexcept;

			/**
			 * @brief Builds the scene octrees.
			 * @param octreeOptions A reference to an octree options struct.
			 * @return bool
			 */
			bool buildOctrees (const SceneOctreeOptions & octreeOptions) noexcept;

			/**
			 * @brief Destroys the scene octrees.
			 * @return void
			 */
			void destroyOctrees () noexcept;

			/**
			 * @brief Checks the entity location inside all octrees.
			 * @param entity A reference to an entity smart pointer.
			 * @return void
			 */
			void checkEntityLocationInOctrees (const std::shared_ptr< AbstractEntity > & entity) const noexcept;

			/**
			 * @brief Executes a collision test between scene at a sector.
			 * @note This is a recursive method with sub-sector.
			 * @param sector A reference to the current sector tested.
			 * @return void
			 */
			void sectorCollisionTest (const OctreeSector< AbstractEntity, true > & sector) noexcept;

			/**
			 * @brief Checks if a scene node is clipping with the scene area boundaries.
			 * @param entity A reference to an entity smart pointer.
			 * @return void
			 */
			void clipWithBoundingSphere (const std::shared_ptr< AbstractEntity > & entity) const noexcept;

			/**
			 * @brief Checks if a scene node is clipping with the scene area boundaries.
			 * @param entity A reference to an entity smart pointer.
			 * @return void
			 */
			void clipWithBoundingBox (const std::shared_ptr< AbstractEntity > & entity) const noexcept;

			/**
			 * @brief Checks a renderable instance for rendering.
			 * @param renderableInstance A reference to renderable instance smart pointer.
			 * @return void
			 */
			void checkRenderableInstance (const std::shared_ptr< Graphics::RenderableInstance::Abstract > & renderableInstance) noexcept;

			/**
			 * @brief Initializes a renderable instance with the scene render targets.
			 * @param renderableInstance A reference to renderable instance smart pointer.
			 * @return void
			 */
			void initializeRenderableInstance (const std::shared_ptr< Graphics::RenderableInstance::Abstract > & renderableInstance) const noexcept;

			/**
			 * @brief Initializes a render target with renderable instances.
			 * @param renderTarget A reference to a render target smart pointer.
			 * @return void
			 */
			void initializeRenderTarget (const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget) const noexcept;

			/**
			 * @brief Prepare the render passes according to the scene.
			 * @param renderableInstance A reference to the renderable instance.
			 * @return std::vector< RenderPassType >
			 */
			[[nodiscard]]
			std::vector< Graphics::RenderPassType > prepareRenderPassTypes (const Graphics::RenderableInstance::Abstract & renderableInstance) const noexcept;

			/**
			 * @brief Prepares a renderable instance for a shadow map.
			 * @note This function returns false only if the instance cannot be prepared. 'True' can postpone the preparation.
			 * @param renderableInstance A reference to the renderable instance smart pointer.
			 * @param renderTarget A reference to a render target smart pointer where the renderable instance must get ready.
			 * @return bool
			 */
			[[nodiscard]]
			bool getRenderableInstanceReadyForShadowCasting (const std::shared_ptr< Graphics::RenderableInstance::Abstract > & renderableInstance, const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget) const noexcept;

			/**
			 * @brief Prepares a renderable instance for a specific rendering.
			 * @note This function returns false only if the instance cannot be prepared. 'True' can postpone the preparation.
			 * @param renderableInstance A reference to the renderable instance smart pointer.
			 * @param renderTarget A reference to a render target smart pointer where the renderable instance must get ready.
			 * @return bool
			 */
			[[nodiscard]]
			bool getRenderableInstanceReadyForRender (const std::shared_ptr< Graphics::RenderableInstance::Abstract > & renderableInstance, const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget) const noexcept;

			static constexpr auto CompassDisplay{"+Compass"};
			static constexpr auto GroundZeroPlaneDisplay{"+GroundZeroPlane"};
			static constexpr auto BoundaryPlanesDisplay{"+BoundaryPlane"};

			/* Flag names. */
			static constexpr auto Initialized{0UL};

			/* Render list types. */
			static constexpr auto Opaque{0UL};
			static constexpr auto Translucent{1UL};
			static constexpr auto OpaqueLighted{2UL};
			static constexpr auto TranslucentLighted{3UL};
			static constexpr auto Shadows{4UL};

			Graphics::Renderer & m_graphicsRenderer;
			Audio::Manager & m_audioManager;
			AVConsole::Manager m_AVConsoleManager;
			std::shared_ptr< Graphics::Renderable::AbstractBackground > m_background;
			std::shared_ptr< Graphics::Renderable::SceneAreaInterface > m_sceneArea;
			std::shared_ptr< Graphics::Renderable::SeaLevelInterface > m_seaLevel;
			std::array< std::shared_ptr< Component::Visual >, 3 > m_sceneVisualComponents{nullptr, nullptr, nullptr};
			std::map< std::string , std::shared_ptr< StaticEntity > > m_staticEntities;
			std::shared_ptr< Node > m_rootNode;
			/* FIXME: This shouldn't be a persistent instance here. This is a debug thing. */
			NodeController m_nodeController;
			std::shared_ptr< OctreeSector< AbstractEntity, false > > m_renderingOctree;
			std::shared_ptr< OctreeSector< AbstractEntity, true > > m_physicsOctree;
			LightSet m_lightSet{m_AVConsoleManager};
			std::set< std::shared_ptr< Component::AbstractModifier > > m_modifiers;
			Physics::PhysicalEnvironmentProperties m_physicalEnvironmentProperties{Physics::PhysicalEnvironmentProperties::Earth()};
			Audio::SoundEnvironmentProperties m_soundEnvironmentProperties;
			std::array< RenderBatch::List, 5 > m_renderLists{};
			Saphir::EffectsList m_environmentEffects;
			float m_boundary{0};
			Libs::Randomizer< float > m_randomizer;
			uint64_t m_lifetimeUS{0};
			uint32_t m_lifetimeMS{0};
			size_t m_cycle{0};
			mutable std::mutex m_sceneNodesMutex;
			mutable std::mutex m_staticEntitiesMutex;
			mutable std::mutex m_renderingOctreeMutex;
			mutable std::mutex m_physicsOctreeMutex;
			std::array< bool, 8 > m_flags{
				false/*Initialized*/,
				false/*UNUSED*/,
				false/*UNUSED*/,
				false/*UNUSED*/,
				false/*UNUSED*/,
				false/*UNUSED*/,
				false/*UNUSED*/,
				false/*UNUSED*/
			};
	};
}
